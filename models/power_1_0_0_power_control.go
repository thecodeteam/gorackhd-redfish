package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

/*Power100PowerControl This is the base type for addressable members of an array.

swagger:model Power.1.0.0_PowerControl
*/
type Power100PowerControl struct {

	/* This is the identifier for the member within the collection.
	 */
	MemberID string `json:"MemberId,omitempty"`

	/* Power Control Function name.

	Read Only: true
	*/
	Name string `json:"Name,omitempty"`

	/* This is the manufacturer/provider specific extension moniker used to divide the Oem object into sections.
	 */
	Oem ResourceOem `json:"Oem,omitempty"`

	/* The total amount of power that has been allocated (or budegeted)to  chassis resources.

	Read Only: true
	Minimum: 0
	*/
	PowerAllocatedWatts float64 `json:"PowerAllocatedWatts,omitempty"`

	/* The amount of power not already budgeted and therefore available for additional allocation. (powerCapacity - powerAllocated).  This indicates how much reserve power capacity is left.

	Read Only: true
	Minimum: 0
	*/
	PowerAvailableWatts float64 `json:"PowerAvailableWatts,omitempty"`

	/* The total amount of power available to the chassis for allocation. This may the power supply capacity, or power budget assigned to the chassis from an up-stream chassis.

	Read Only: true
	Minimum: 0
	*/
	PowerCapacityWatts float64 `json:"PowerCapacityWatts,omitempty"`

	/* The actual power being consumed by the chassis.

	Read Only: true
	Minimum: 0
	*/
	PowerConsumedWatts float64 `json:"PowerConsumedWatts,omitempty"`

	/* Power limit status and configuration information for this chassis
	 */
	PowerLimit *Power100PowerLimit `json:"PowerLimit,omitempty"`

	/* Power readings for this chassis.
	 */
	PowerMetrics *Power100PowerMetric `json:"PowerMetrics,omitempty"`

	/* The potential power that the chassis resources are requesting which may be higher than the current level being consumed since requested power includes budget that the chassis resource wants for future use.

	Read Only: true
	Minimum: 0
	*/
	PowerRequestedWatts float64 `json:"PowerRequestedWatts,omitempty"`

	/* The ID(s) of the resources associated with this Power Limit
	 */
	RelatedItem []*Odata400IDRef `json:"RelatedItem,omitempty"`

	/* related item at odata count

	Read Only: true
	*/
	RelatedItemAtOdataCount float64 `json:"RelatedItem@odata.count,omitempty"`

	/* related item at odata navigation link
	 */
	RelatedItemAtOdataNavigationLink *Odata400IDRef `json:"RelatedItem@odata.navigationLink,omitempty"`

	/* status
	 */
	Status *ResourceStatus `json:"Status,omitempty"`
}

// Validate validates this power 1 0 0 power control
func (m *Power100PowerControl) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePowerAllocatedWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerAvailableWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerCapacityWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerConsumedWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerLimit(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerMetrics(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerRequestedWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRelatedItem(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRelatedItemAtOdataNavigationLink(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Power100PowerControl) validatePowerAllocatedWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerAllocatedWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerAllocatedWatts", "body", float64(m.PowerAllocatedWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validatePowerAvailableWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerAvailableWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerAvailableWatts", "body", float64(m.PowerAvailableWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validatePowerCapacityWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerCapacityWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerCapacityWatts", "body", float64(m.PowerCapacityWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validatePowerConsumedWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerConsumedWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerConsumedWatts", "body", float64(m.PowerConsumedWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validatePowerLimit(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerLimit) { // not required
		return nil
	}

	if m.PowerLimit != nil {

		if err := m.PowerLimit.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *Power100PowerControl) validatePowerMetrics(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerMetrics) { // not required
		return nil
	}

	if m.PowerMetrics != nil {

		if err := m.PowerMetrics.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *Power100PowerControl) validatePowerRequestedWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerRequestedWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerRequestedWatts", "body", float64(m.PowerRequestedWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validateRelatedItem(formats strfmt.Registry) error {

	if swag.IsZero(m.RelatedItem) { // not required
		return nil
	}

	for i := 0; i < len(m.RelatedItem); i++ {

		if swag.IsZero(m.RelatedItem[i]) { // not required
			continue
		}

		if m.RelatedItem[i] != nil {

			if err := m.RelatedItem[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Power100PowerControl) validateRelatedItemAtOdataNavigationLink(formats strfmt.Registry) error {

	if swag.IsZero(m.RelatedItemAtOdataNavigationLink) { // not required
		return nil
	}

	if m.RelatedItemAtOdataNavigationLink != nil {

		if err := m.RelatedItemAtOdataNavigationLink.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *Power100PowerControl) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {

		if err := m.Status.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}
